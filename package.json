import React, { useState } from 'react';
import { Slider } from '@/components/ui/slider';
import { Button } from '@/components/ui/button';
import { Card, CardHeader, CardContent } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';

const categories = ['Travelling', 'Buckness', 'Storytelling', 'Character', 'Basics', 'Liveness', 'Musicality'];

const KrumperScoreCard = ({ krumper, judgeNumber, onScoreChange, scores }) => {
  const handleSliderChange = (category, value) => {
    onScoreChange(`judge${judgeNumber}`, krumper, category, value[0]);
  };

  return (
    <Card className="mb-4">
      <CardHeader>Judge {judgeNumber} - Krumper {krumper}</CardHeader>
      <CardContent>
        {categories.map((category) => (
          <div key={category} className="mb-4">
            <label className="block mb-2">{category}: {scores[category] || 0}</label>
            <Slider
              min={0}
              max={5}
              step={1}
              value={[scores[category] || 0]}
              onValueChange={(value) => handleSliderChange(category, value)}
            />
          </div>
        ))}
      </CardContent>
    </Card>
  );
};

const KrumpJudgingApp = () => {
  const [rounds, setRounds] = useState(1);
  const [currentRound, setCurrentRound] = useState(1);
  const [scores, setScores] = useState({
    1: { A: { judge1: {}, judge2: {}, judge3: {} }, B: { judge1: {}, judge2: {}, judge3: {} } },
    2: { A: { judge1: {}, judge2: {}, judge3: {} }, B: { judge1: {}, judge2: {}, judge3: {} } },
    3: { A: { judge1: {}, judge2: {}, judge3: {} }, B: { judge1: {}, judge2: {}, judge3: {} } },
  });
  const [winner, setWinner] = useState(null);
  const [finalScores, setFinalScores] = useState({ A: {}, B: {} });
  const [isJudgingComplete, setIsJudgingComplete] = useState(false);

  const handleScoreChange = (judge, krumper, category, value) => {
    setScores((prevScores) => ({
      ...prevScores,
      [currentRound]: {
        ...prevScores[currentRound],
        [krumper]: {
          ...prevScores[currentRound][krumper],
          [judge]: {
            ...prevScores[currentRound][krumper][judge],
            [category]: value,
          },
        },
      },
    }));
  };

  const calculateTotalScore = (roundScores) => {
    const totalByCategory = {};
    categories.forEach(category => {
      totalByCategory[category] = Object.values(roundScores).reduce((sum, judgeScores) => {
        return sum + (judgeScores[category] || 0);
      }, 0);
    });
    return totalByCategory;
  };

  const determineWinner = () => {
    let totalScores = { A: {}, B: {} };

    categories.forEach(category => {
      totalScores.A[category] = 0;
      totalScores.B[category] = 0;
    });

    for (let round = 1; round <= rounds; round++) {
      const roundScoresA = calculateTotalScore(scores[round].A);
      const roundScoresB = calculateTotalScore(scores[round].B);

      categories.forEach(category => {
        totalScores.A[category] += roundScoresA[category];
        totalScores.B[category] += roundScoresB[category];
      });
    }

    setFinalScores(totalScores);

    const totalA = Object.values(totalScores.A).reduce((sum, score) => sum + score, 0);
    const totalB = Object.values(totalScores.B).reduce((sum, score) => sum + score, 0);

    if (totalA > totalB) {
      setWinner('Krumper A');
    } else if (totalB > totalA) {
      setWinner('Krumper B');
    } else {
      setWinner('Tie');
    }

    setIsJudgingComplete(true);
  };

  const nextRound = () => {
    if (currentRound < rounds) {
      setCurrentRound(currentRound + 1);
    } else {
      determineWinner();
    }
  };

  const resetJudging = () => {
    setCurrentRound(1);
    setScores({
      1: { A: { judge1: {}, judge2: {}, judge3: {} }, B: { judge1: {}, judge2: {}, judge3: {} } },
      2: { A: { judge1: {}, judge2: {}, judge3: {} }, B: { judge1: {}, judge2: {}, judge3: {} } },
      3: { A: { judge1: {}, judge2: {}, judge3: {} }, B: { judge1: {}, judge2: {}, judge3: {} } },
    });
    setWinner(null);
    setFinalScores({ A: {}, B: {} });
    setIsJudgingComplete(false);
  };

  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold mb-4">Krump Judging App</h1>
      {!isJudgingComplete && (
        <>
          <div className="mb-4">
            <label className="block mb-2">Number of Rounds:</label>
            <Select onValueChange={(value) => setRounds(parseInt(value))}>
              <SelectTrigger className="w-32">
                <SelectValue placeholder="Rounds" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="1">1</SelectItem>
                <SelectItem value="2">2</SelectItem>
                <SelectItem value="3">3</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <h2 className="text-xl font-semibold mb-4">Round {currentRound}</h2>
          <Tabs defaultValue="judge1">
            <TabsList>
              <TabsTrigger value="judge1">Judge 1</TabsTrigger>
              <TabsTrigger value="judge2">Judge 2</TabsTrigger>
              <TabsTrigger value="judge3">Judge 3</TabsTrigger>
            </TabsList>
            {['judge1', 'judge2', 'judge3'].map((judge, index) => (
              <TabsContent key={judge} value={judge}>
                <div className="flex space-x-4">
                  <KrumperScoreCard
                    krumper="A"
                    judgeNumber={index + 1}
                    onScoreChange={handleScoreChange}
                    scores={scores[currentRound].A[judge]}
                  />
                  <KrumperScoreCard
                    krumper="B"
                    judgeNumber={index + 1}
                    onScoreChange={handleScoreChange}
                    scores={scores[currentRound].B[judge]}
                  />
                </div>
              </TabsContent>
            ))}
          </Tabs>
          <Button onClick={nextRound} className="mt-4">
            {currentRound < rounds ? 'Next Round' : 'Finish and Determine Winner'}
          </Button>
        </>
      )}
      {isJudgingComplete && (
        <div className="mt-4">
          <h2 className="text-xl font-semibold mb-2">Final Results</h2>
          <div className="grid grid-cols-3 gap-4">
            <div>
              <h3 className="text-lg font-semibold mb-2">Category</h3>
              {categories.map(category => (
                <p key={category} className="mb-1">{category}</p>
              ))}
              <p className="font-bold mt-2">Total Score</p>
            </div>
            <div>
              <h3 className="text-lg font-semibold mb-2">Krumper A</h3>
              {categories.map(category => (
                <p key={category} className="mb-1">{finalScores.A[category]}</p>
              ))}
              <p className="font-bold mt-2">{Object.values(finalScores.A).reduce((sum, score) => sum + score, 0)}</p>
            </div>
            <div>
              <h3 className="text-lg font-semibold mb-2">Krumper B</h3>
              {categories.map(category => (
                <p key={category} className="mb-1">{finalScores.B[category]}</p>
              ))}
              <p className="font-bold mt-2">{Object.values(finalScores.B).reduce((sum, score) => sum + score, 0)}</p>
            </div>
          </div>
          <h3 className="text-lg font-semibold mt-4 mb-4">Winner: {winner}</h3>
          <Button onClick={resetJudging} className="mt-2">Start New Judging</Button>
        </div>
      )}
    </div>
  );
};

export default KrumpJudgingApp;
